## 1 Java的常用数据库对象包括？ 

表 视图 函数 索引 触发器 存储过程 用户 



## 2 索引的分类？ 

Mysql常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引 

Mysql各种索引区别： 

**普通索引：**最基本的索引，没有任何限制

 **唯一索引：**与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。

 **主键索引：**它是一种特殊的唯一索引，不允许有空值。 

**全文索引：**仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗费时间和空间。 

**组合索引：**为了更多的提高mysql效率可建立组合索引，遵循**”最左前缀“**原则。创建复合索引时应该将最常用（频率）作限制条件的列放在最左边，依次递减。组合索引要不全用要不都不要用 



按照索引的顺序来划分：聚簇索引和非聚簇索引

**聚簇索引是顺序结构与数据存储物理结构一致的一种索引，并且一个表的聚簇索引只能有唯一的一条；** 

只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。聚簇索引要比非聚簇索引查询效率高很多。 聚集索引这种主+辅索引的好处是，当发生数据行移动或者页分裂时，辅助索引树不需要更新，因为辅助索引树存储的是主索引的主键关键字，而不是数据具体的物理地址。  ***默认*情况下一个数据表的*聚簇索引*是其*主键*** 

**InnoDB使用的是聚簇索引** 



**非聚簇索引记录的物理顺序与数据的存储物理结构没有关系；一个表对应的非聚簇索引可以有多条，根据不同列的约束可以建立不同要求的非聚簇索引；** 

**MyISAM的是非聚簇索引** 



## 3 SQL的优化方法？ 

对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描



2、避免在 where 子句中使用 != 或 <> 操作符。 

3、避免在 where 子句中使用 or来链接条件。 

4、少用 in 或 not in。 

5、注意 like 中通配符的使用。 

6、避免在 where 子句中对字段进行表达式操作。 

7、避免在 where 子句中对字段进行函数操作。 

8、在子查询中，用 exists 代替 in 是一个好的选择。



## 4.2 Mysql的优化？

1、开启查询缓存，将相同的查询结果放到缓存中，

2、使用Limit限制查询数量

3、为关键字段添加索引

4、进行Join时，为Join字段添加索引

5、垂直分割，将多字段的大表分割为几个小表

6、主从复制，读写分离：读写分离适用于那种读远大于写的场景

7、采用分布式的，可以使用memcache进行共享缓存数据（memcache是一个高性能的分布式的内存对象缓存系统 ）



## 5 数据库为什么使用B+树？

参考：[B树B-树和B+树的总结](https://www.jianshu.com/p/92d15df75027)

B树和B+树都是基于二叉树实现的多路搜索树，利用平衡树的优势可以加快查询的稳定性和速度：

B树：分支节点和叶子节点都存储着关键字数据，查询时需要遍历，常用于磁盘的文件索引

B+树：关键字数据存储在叶子节点，分支节点存储均为索引，查询时只需扫描叶子节点，常用于数据库索引。



**B树和B+树的区别：**

关键字个数不同：B数k-1个关键字，B+树分支节点M个关键字，叶子节点也有M个

数据存储位置不同：分支节点和叶子节点

查询不同：根节点到叶子节点

分支节点存储的信息不同：



**使用B+树是因为：**

参考：[【数据结构之二叉树】（二）B+树比B树更适合做文件索引的原因](https://blog.csdn.net/cangchen/article/details/44818485)

更快的检索速度：每个节点可以存多个数据，出度大，空间利用率大，可减少I/O次数

利用计算机的预读特性：根据局部性原理，可以一次性读多个块（页）

增删节点时效率更高：叶子节点时有序的链表存储的，增删效率高

稳定：查询路径都是从根节点到叶子节点，查询路径相同



## 6 什么是索引？为什么要建立索引？

Mysql中有两种索引：Hash、B树

优点：加快查询，不需要顺序遍历

缺点：维护索引，占用额外的空间



## 7 何时建立索引呢？ 

经常使用的字段，join字段添加索引，列值较多的建立索引

频繁更新的表，数据量小的表，列值少的不建立索引



在索引优化时：选择利用最左前缀原则； 使用短索引； 不要过度索引，只保持所需的索引； 



## 8 mysql建立索引的几大原则？ 

1．选择唯一性索引

2．为经常需要排序、分组和联合操作的字段建立索引

3．为常作为查询条件的字段建立索引

4．限制索引的数目

5．尽量使用数据量少的索引

6．尽量使用前缀来索引

7．删除不再使用或者很少使用的索引

8 . 最左前缀匹配原则，非常重要的原则。

9 .=和in可以乱序。

10 . 尽量选择区分度高的列作为索引。

11 .索引列不能参与计算，保持列“干净”。

12 .尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可



## 9 什么时候会索引失效呢？

1、为单字段建立索引，但是查询条件是多字段

2、建立了联合索引，但是where条件是单字段，没有符合最左前缀匹配选择，

3、对索引的列进行计算（or in exist + - * / < > % like'%_'）

4、类型错误，字符类型的字段没有加上引号

5、子查询使用了内部函数

6、全表扫描快于使用索引时，



## 10 MySQL存放IP地址 用数值型有什么好处?

使用无符号的int，因为查询效率高，且存储空间合理，查询时可以基于范围between 查询，且地段时定长的，4字节，有查询优势。

若用String，可读性好但占存储空间



## 11 Mysql的存储引擎有哪些？ 

Mysql的常见存储引擎有四个：MylSAM、InnoDB、MEMORY、Merge 、Archive 、Heap

**MyISAM和InnoDB存储引擎：**只支持B树索引， 也就是说默认使用B树，不能够更换 

**MEMORY/HEAP存储引擎：**支持Hash和B树索引 



**1）MylSAM：** 是MySql使用的是**表级锁；**拥有较高的插入、查询速度，因此适合筛选大量数据；**但不支持事务，也不支持外键；支持全文索引，最大的缺陷是崩溃后无法安全恢复。** 

**使用场景：**适合筛选大量数据，读性能稳定，高可用。 

备注：Mysql在V5.1之前默认存储引擎是MyISAM；在此之后默认存储引擎是InnoDB 

>使用MyISAM引擎创建数据库，将产生3个文件，文件的名字以表名字开始，扩展名是文件类型：例如创建了boy_demo表
>
>- boy_demo.frm 存储表定义；
>- boy_demo.MYD 存储数据；
>- boy_demo.MYI 存储索引；



**2）InnoDB** InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎；（5.6加入了全文检索） 

**使用场景：**支持事务和外键约束，可处理高并发请求 

>具有事务的特性，与ACID兼容； 适合更新密集的表，处理多重并发的更新请求； 支持外键的约束； 支持自动增加列ATUO_INCREMENT属性； 



**3）memery**
数据是放在内存中的，并且默认使用HASH/Tree索引

**特点：**速度快，响应时间短

**使用场景：**目标数据较小，且被频繁访问，临时数据可放于内存表中，内存表中数据即使丢失也不会有太大影响。



**4） Archive存储引擎**

Archive存储引擎置只支持INSERT和SELECT操作，支持行锁，但本身并不是事务安全的存储引擎，其最大的优点是其具有较好的压缩比，压缩比一般可达到1:10，可以将同样的数据以更小的磁盘空间占用来存储。

Archive存储引擎非常适合存储归档数据，如历史数据、日志信息数据等等，这类数据往往数据量非常大，并且基本只有INSERT和SELECT操作，使用这个存储引擎可以非常节约磁盘空间。



**5）Merge** Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。 



**总结：** 

插入和查询，适合筛选大量数据；---MyISAM 

事务和并发---InnoDB 

临时表、中间结果---Memory 

高并发插入查询，归档数据---Archive 



## Mysql的范式

数据库完整性： 实体完整性：主键 唯一且不为空 参照完整性：外键 可以为空 用户自定义完整性：约束条件等 

1）第一范式：原子性

确保每列的原子性。也就是每个属性都是不可再分的。



2）第二范式：主键属性

在第一范式的基础上，要求非主属性都要和码有完全依赖关系。
在第一范式的基础，确保表中的每列都和主键相关



3）第三范式：去点依赖关系

消除了非主属性对于主键的传递函数依赖。 



4）BC范式

BC范式在 3NF 的基础上**消除主属性**对于码的部分与传递函数依赖。 



## 12 存储过程的优缺点

[存储过程的优缺点](https://www.cnblogs.com/zhangweizhong/p/3871785.html)

1）运行速度： 

对于很简单的sql，存储过程没有什么优势。对于复杂的业务逻辑，因为在存储过程创建的时候，数据库已经对其进行了一次解析和优化。存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用，所以执行速度会比普通sql快。     

2）减少网络传输： 

存储过程直接就在数据库服务器上跑，所有的数据访问都在数据库服务器内部进行，不需要传输数据到其它服务器，所以会减少一定的网络传输。

3）可维护性 ：

存储过程有些时候比程序更容易维护，这是因为可以实时更新DB端的存储过程。 

4）增强安全性：

提高代码安全，防止 SQL注入。 

5）可扩展性： 

应用程序和数据库操作分开，独立进行，而不是相互在一起。方便以后的扩展和DBA维护优化。 



## 13 实际操作

1）建立索引



2）查询一周内用户点击率最多的5个用户



​	















